\begin{frame}{Python: A Primer}
\protect\hypertarget{python-a-primer}{}
A HMS Research Computing Training Session

Alex Truong

alex\_truong@hms.harvard.edu

\url{https://rc.hms.harvard.edu/}

\begin{block}{Introduction}
\protect\hypertarget{introduction}{}
Why Python?

\begin{block}{Python is\ldots{}}
\protect\hypertarget{python-is}{}
simple - resembles plain English

easy - no need to declare (in most cases), memory management

clean - whitespace-formatted for visibility

interpreted - good for developing, bad for performance (more on this
later)

\begin{longtable}[]{@{}ll@{}}
\toprule
Interpreted & Compiled\tabularnewline
\midrule
\endhead
Rapid prototyping & Faster Performance\tabularnewline
Requires interpreter & Requires compiler (GCC, etc.)\tabularnewline
Dynamic typing (sort of) & Static typing\tabularnewline
Code-level optimization & Code- and Compiler-level
optimization\tabularnewline
\bottomrule
\end{longtable}
\end{block}
\end{block}

\begin{block}{On to learning Python! But first, a brief aside\ldots{}}
\protect\hypertarget{on-to-learning-python-but-first-a-brief-aside}{}
\end{block}
\end{frame}

\begin{frame}[fragile]{Accessing Python on O2}
\protect\hypertarget{accessing-python-on-o2}{}
\begin{block}{Logging into O2}
\protect\hypertarget{logging-into-o2}{}
Open a terminal and ssh into o2.hms.harvard.edu

\begin{verbatim}
    $ ssh rc_training01@o2.hms.harvard.edu
    rc_training01@o2.hms.harvard.edu's password: 
    
    rc_training01@login01:~$
\end{verbatim}
\end{block}

\begin{block}{Accessing Python on O2}
\protect\hypertarget{accessing-python-on-o2-1}{}
\begin{verbatim}
    $ module avail python
    No modules found!
    Use "module spider" to find all possible modules.
    Use "module keyword key1 key2 ..." to search for all possible modules matching
    any of the "keys".
    
    $ module spider python
       Versions:
          python/2.7.12
          python/3.6.0
          python/3.7.4
\end{verbatim}
\end{block}

\begin{block}{Accessing Python on O2 cont'd.}
\protect\hypertarget{accessing-python-on-o2-contd.}{}
\begin{verbatim}
    $ module spider python/3.6.0
`    You will need to load all module(s) on any one of the lines below before the "python/3.6.0" module is available to     load.
    
          gcc/6.2.0
    (snip)
    
    $ module load gcc/6.2.0 python/3.6.0
    
    $ which python
    /n/app/python/3.6.0/bin/python
    
    $ python3
    Python 3.6.0 (default, May  2 2018, 17:23:32)
    [GCC 6.2.0] on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>
\end{verbatim}

Today's course will use 3.6.0. (To exit the interpreter, type ctrl+D,
\texttt{exit()}, or \texttt{quit()}.)
\end{block}

\begin{block}{Alternately, virtual environment:}
\protect\hypertarget{alternately-virtual-environment}{}
\begin{verbatim}
    $ module load gcc/6.2.0 python/3.6.0
    $ which virtualenv
    /n/app/python/3.6.0/bin/virtualenv
    $ virtualenv nameofenv --system-site-packages
    New python executable in nameofenv/bin/python
    Installing setuptools, pip, wheel...done.
    $ source nameofenv/bin/activate
    (nameofenv)$ which python3
    ~/nameofenv/bin/python
\end{verbatim}

To deactivate:

\begin{verbatim}
    (nameofenv)$ deactivate
    $
\end{verbatim}
\end{block}

\begin{block}{Why virtual environment?}
\protect\hypertarget{why-virtual-environment}{}
Python has modules. if you want to install your own, you need a virtual
environment.

The version on O2 has a certain number of builtin modules; the
\texttt{-\/-system-site-packages} flag allows your virtual environment
to inherit those packages so you don't have to reinstall them yourself,
if you're using python modules that are older than 3.7.4.

For more information, you can visit our
\href{https://wiki.rc.hms.harvard.edu/display/O2/Personal+Python+Packages}{Personal
Python Packages wiki page}.
\end{block}

\begin{block}{Installing Python modules}
\protect\hypertarget{installing-python-modules}{}
To install modules, generally use \texttt{pip3} or \texttt{easy-install}
(we recommend \texttt{pip3}):

\begin{verbatim}
    (nameofenv)$ pip3 install packagename
\end{verbatim}

If that doesn't work (e.g.~you've downloaded the archive manually),
follow the instructions in the provided README file, but it'll go
something like

\begin{verbatim}
    (nameofenv)$ python3 setup.py install
\end{verbatim}

(some will have you use \texttt{build} before \texttt{install}). Make
sure you read the (hopefully provided) instructions when installing
modules manually.
\end{block}

\begin{block}{Viewing modules}
\protect\hypertarget{viewing-modules}{}
to see which external modules have been installed/compatible with the
package installer (\texttt{pip3}):

\begin{verbatim}
$ pip3 freeze
bx-python==0.7.3
cycler==0.10.0
funcsigs==1.0.2
matplotlib==1.5.3
\end{verbatim}
\end{block}

\begin{block}{Viewing modules cont.}
\protect\hypertarget{viewing-modules-cont.}{}
To see ALL modules available on your Python build, type either of:

\begin{verbatim}
$ python3 -c "help('modules')"
\end{verbatim}

and

\begin{verbatim}
$ python3
Python 3.6.0 (default, May  2 2018, 17:23:32)
[GCC 6.2.0] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> help('modules')
\end{verbatim}
\end{block}

\begin{block}{Viewing modules cont.}
\protect\hypertarget{viewing-modules-cont.-1}{}
and it will output something like:

\begin{verbatim}
Please wait a moment while I gather a list of all available modules...

(there might be some warnings here...)

276-pkg_graph       bisect              keyword             sha
BaseHTTPServer      blah                lib2to3             shelve
Bastion             brainteaser         linecache           shlex
CDROM               bsddb               linuxaudiodev       shutil
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Let's Learn Python!}
\protect\hypertarget{lets-learn-python}{}
\begin{block}{Syntax}
\protect\hypertarget{syntax}{}
Statements are terminated by newlines (e.g.~enter key)

Examples:

\begin{verbatim}
>>> a = 1
>>> print("hello world")
hello world
\end{verbatim}
\end{block}

\begin{block}{Nuances: Quotations}
\protect\hypertarget{nuances-quotations}{}
In general, double and single quotes are interchangeable, both for
printing and argument passing:

\begin{verbatim}
>>> print("hello world")
hello world
>>> print('hello world')
hello world

>>> str = 'abcdefg'
>>> str1 = "abcdefg"
>>> str == str1
True
\end{verbatim}
\end{block}

\begin{block}{Nuances: Escaped characters}
\protect\hypertarget{nuances-escaped-characters}{}
Sometimes, you'll need to escape (backslash) certain special characters
to get them to display correctly when printing. For example, if you want
to preserve double quotations in your string:

\begin{verbatim}
>>> print(""hello world"")
  File "", line 1
    print(""hello world"")
                ^
SyntaxError: invalid syntax
>>> print("\"hello world\"")
"hello world"
\end{verbatim}

A list of escape characters can be found at the
\href{https://docs.python.org/3/reference/lexical_analysis.html\#literals}{Python
documentation} and elsewhere on the internet.
\end{block}

\begin{block}{Comments}
\protect\hypertarget{comments}{}
Comments are used to make code more legible. In python, they are denoted
with the octothorpe:

\begin{verbatim}
    #!/usr/bin/env python3
    ...
    # do stuff here
    ...
\end{verbatim}

Multi-line comments can either be manually be broken down, or held in a
docstring with triple quotes:

\begin{verbatim}
    """
    this is a
    multi-line comment
    """
\end{verbatim}

We'll revisit the \texttt{\#!} line in a little bit.
\end{block}

\begin{block}{Basic Features}
\protect\hypertarget{basic-features}{}
Data structures, looping, etc.

\begin{block}{Data types}
\protect\hypertarget{data-types}{}
Python is dynamically typed; there is no need to declare
(e.g.~\texttt{int\ n\ =\ num}). You can also reassign:

\begin{verbatim}
    >>> number = 1
    >>> number
    1
    >>> number = 2
    >>> number
    2
    >>> str = 'abc'
    >>> str
    'abc'
    >>> str = 'def'
    >>> str
    'def'
    >>> str = 1
    >>> str
    1
\end{verbatim}
\end{block}

\begin{block}{Data types, an aside}
\protect\hypertarget{data-types-an-aside}{}
However, strings (and some other stuff like tuples) are not
\emph{mutable}; you cannot modify its content. When you reassign the
variable as seen previously, you're actually generating a new object.
You can't modify the original object:

\begin{verbatim}
    >>> s = "abc"
    >>> s[0] 
    'a'
    >>> s[0] = "o"
    Traceback (most recent call last):
      File "", line 1, in 
    TypeError: 'str' object does not support item assignment
\end{verbatim}

The above example was shamelessly lifted off
\href{http://stackoverflow.com/questions/8056130/immutable-vs-mutable-types-python}{Stack
Overflow}.
\end{block}

\begin{block}{Back to data types}
\protect\hypertarget{back-to-data-types}{}
Like most languages, Python has higher level data structures. Of note
are lists (arrays) and dictionaries. Relatedly, there are also tuples
and sets. Each structure fills different niches.
\end{block}

\begin{block}{Lists}
\protect\hypertarget{lists}{}
Lists are the most versatile; they are the effective equivalent of
arrays in other languages. They are ordered, and you can fetch specific
indices. You can mix and match types, have duplicates, nest lists, etc.
To generate a list:

\begin{verbatim}
    >>> lst = [] #initialize a list of indeterminate size
    >>> lst.append('a')
    >>> lst
    ['a']
    >>>lst.extend(['b', 'c'])
    >>>lst
    ['a', 'b', 'c']
    
    >>> lst2 = [None]*5 #initialize a list of predetermined size (an array)
    >>> lst2
    [None, None, None, None, None]
    >>> lst2[1] = 'foo'
    >>>lst2[1]
    'foo'
    >>> lst2
    [None, 'foo', None, None, None]
\end{verbatim}
\end{block}

\begin{block}{Sets}
\protect\hypertarget{sets}{}
Sets are lists that do not allow duplicates. Sets are useful if you need
to take unions, intersections, etc. To generate sets:

\begin{verbatim}
    >>> st = set(lst)
    >>> st
    {'a', 'c', 'b'}
    
    >>> lst3 = [1, 1, 2, 3, 4, 4]
    >>> st2 = set(lst3)
    >>> st2
    {1, 2, 3, 4}
    
    >>> st3 = {1, 2, 3}
    >>> st3
    {1, 2, 3}
\end{verbatim}
\end{block}

\begin{block}{Sample set operations}
\protect\hypertarget{sample-set-operations}{}
Here are some elementary operations you can perform with sets:

\begin{verbatim}
    >>> set1 = {1, 2, 3}
    >>> set2 = {3, 4, 5}
    >>> set1 | set2        # union
    {1, 2, 3, 4, 5}
    >>> set1 & set2        # intersection
    {3}
    >>> set1 - set2        # set difference
    {1, 2}
    >>> set2 - set1
    {4, 5}
    >>> set1 ^ set2        # symmetric difference
    {1, 2, 4, 5}
    >>> set2 ^ set1
    {1, 2, 4, 5}
\end{verbatim}

More information can be found in the
\href{https://docs.python.org/2/library/sets.html}{documentation}.
\end{block}

\begin{block}{Tuples}
\protect\hypertarget{tuples}{}
Tuples are lists, but immutable. Once created, they cannot be modified.
If you know the size of your data structure, tuples are preferred over
lists because Python will know exactly how much memory to allocate. To
create tuples:

\begin{verbatim}
    >>> empty_tuple = ()
    >>> empty_tuple
    ()
    >>> one_element = 1,
    >>> one_element
    (1,)
    >>> mixed_tuple = (1, 'a', [1, 'a'])
    >>> mixed_tuple
    (1, 'a', [1, 'a'])
    >>> lst = [1, 2, 3]
    >>> tuple_from_list = tuple(lst)
    >>> tuple_from_list
    (1, 2, 3)
\end{verbatim}
\end{block}

\begin{block}{Dictionaries}
\protect\hypertarget{dictionaries}{}
Dictionaries are associative collections (maps). They are composed of
key:value pairs (most of the time). To create a dictionary:

\begin{verbatim}
    >>> empty_dict = {}    # careful not to confuse this with empty sets; to initialize an empty set, use set()
    >>> empty_dict
    {}
    >>> dict1 = {1: 'a', 2: 'b', 3: 'c'}
    >>> dict1
    {1: 'a', 2: 'b', 3: 'c'}
    >>> dict2 = dict([(1, 'a'), (2, 'b'), (3, 'c')])
    >>> dict2
    {1: 'a', 2: 'b', 3: 'c'}
    >>> dict3 = dict(a=1, b=2, c=3)     # only works if keys are strings
    >>> dict3
    {'a': 1, 'c': 3, 'b': 2}
    >>> dict4 = dict(1=a, 2=b, 3=c)
      File "", line 1
    SyntaxError: keyword can't be an expression
\end{verbatim}
\end{block}

\begin{block}{Basic data structure manipulations}
\protect\hypertarget{basic-data-structure-manipulations}{}
lists are zero-indexed (count from 0), and you can reference positions
like so:

\begin{verbatim}
    >>> lst = [1, 2, 3, 4, 5]
    >>> lst[1]
    2
    >>> lst[1:]     # sublist from second entry to end
    [2, 3, 4, 5]
    >>> lst[1:3]    # note that the fourth element is omitted; when end indices are specified, Python stops BEFORE they are reached
    [2, 3]
    >>> lst[:3]     # sublist from beginning to fourth entry
    [1, 2, 3]
    >>> lst[1::2]  # sublist from second to end, every other element
    [2, 4]
    >>> lst[-1]     # last entry (reverse indexing)
    5
    >>> lst2 = [1, 2, 3, [4, 5]]    # nested list
    >>> lst2[3][1]  # specify all relevant indices from outside in
    5
\end{verbatim}
\end{block}

\begin{block}{Basic data structure manipulations cont.}
\protect\hypertarget{basic-data-structure-manipulations-cont.}{}
Dictionaries don't have indices to reference, but they do have keys and
values. To interact with dictionaries:

\begin{verbatim}
    >>> dict1 = {1: 'a', 2: 'b', 3: 'c'}
    >>> dict1[1]
    'a'
    >>> dict1.keys()
    [1, 2, 3]
    >>> dict1.values()
    ['a', 'b', 'c']
\end{verbatim}

There's a lot more you can do with these data structures. If you find
yourself wondering if \emph{x} data structure can do \emph{y} thing,
feel free to search for an answer. More often than not, there will be a
solution!
\end{block}

\begin{block}{Flow Control}
\protect\hypertarget{flow-control}{}
for, while, if/else
\end{block}

\begin{block}{For loops}
\protect\hypertarget{for-loops}{}
For loops are very straightforward to implement, if a little obfuscated.
To iterate over a list:

\begin{verbatim}
    >>> things = ['apple', 'banana', 'cherry']
    >>> for thing in things:
    ...     print(thing)
    ...
    apple
    banana
    cherry
    >>>
\end{verbatim}

This will go through every item in your list (or tuple or whatever) in
order. If you also wanted to fetch indices, you'd use:

\begin{verbatim}
    >>> for idx, thing in enumerate(things):
    ...     print(idx, thing)
    ...
    0 apple
    1 banana
    2 cherry
    >>>
\end{verbatim}

The \texttt{enumerate()} function is actually an \emph{iterator} that
spits out a tuple consisting of (index, value) and assigns each to idx,
name. This is called a \textbf{named tuple}.

The \texttt{for\ a\ in\ b} structure can be replaced with any generic
construct (within reason). For a generic loop, you can do something
like:

\begin{verbatim}
    >>>for i in range(5):
    ...     print(i)
    ...
    0
    1
    2
    3
    4
\end{verbatim}
\end{block}

\begin{block}{While loops}
\protect\hypertarget{while-loops}{}
Similar in function to \texttt{for} loops, while loops are used to
iterate, and are useful if you don't know how long to iterate for
(e.g.~searching for convergence, etc.). A generic while loop looks like
this:

\begin{verbatim}
    >>>toggle = True
    >>> while toggle == True:
    ...     toggle = False
    ...     print(toggle)
    ...
    False
\end{verbatim}

A very simplistic example, but the above while loop runs one iteration,
then exits because \texttt{toggle} is no longer \texttt{True}.
\end{block}

\begin{block}{If/elif/else}
\protect\hypertarget{ifelifelse}{}
\texttt{if/else} statements are useful when you need to handle different
cases in your workflow. A generic if/elif/else statement structure:

\begin{verbatim}
    # take some input (let's say, a number)
    if input == 0:       #if input is zero
        print('zero')
    elif input % 2 == 0: #if input is otherwise even
        print('even')
    else:                #if input is odd
        print ('odd')
\end{verbatim}

You may use as many \texttt{elif}s as you require to solve your problem.
\end{block}

\begin{block}{An aside: try/except}
\protect\hypertarget{an-aside-tryexcept}{}
Python has the interesting distinction of relatively lightweight
exception handling. Exceptions are only computationally expensive if
they trigger. For more information,
\href{https://www.jeffknupp.com/blog/2013/02/06/write-cleaner-python-use-exceptions/}{this
page has a good analysis of if/else versus try/except}.
\end{block}
\end{block}

\begin{block}{A few pertinent modules}
\protect\hypertarget{a-few-pertinent-modules}{}
\begin{block}{SciPy}
\protect\hypertarget{scipy}{}
SciPy has a bunch of interesting functions that automate various aspects
of scientific computing, like statistics and higher-level mathematics.
Most of these are callable in one line. Briefly, this is how to use the
SciPy module. You will need to consult the
\href{http://docs.scipy.org/doc/}{documentation} for complex usage.

\begin{verbatim}
    >>> from scipy import constants        # `from scipy import *` will not behave as expected
    >>> constants.c                        # speed of light
    299792458.0
    >>> from scipy.stats import norm
    >>> norm.cdf(5, 0, 3)                  # P(x<5) if X~N(0,3)
    0.9522096477271853
\end{verbatim}
\end{block}

\begin{block}{NumPy}
\protect\hypertarget{numpy}{}
Numpy is the go-to module if you need to perform complex arithmetic or
do matrix operations (manipulate data frames. It is much more efficient
(and easy to use) than using system Python utilities. An example:

\begin{verbatim}
    >>> import numpy as np       # the general way; using `as` allows you to set an alias (if the name is too long to type)
    >>> cvalues = [25.3, 24.8, 26.9, 23.9]    # a typical python list of Celcius values
    >>> C = np.array(cvalues)       # create a numpy array
    >>> print(C)
    [ 25.3  24.8  26.9  23.9]       # note that they look identical
    >>> print(C * 9 / 5 + 32)       # convert to Fahrenheit using scalar multiplication
    [ 77.54  76.64  80.42  75.02]
    >>> fvalues = [x*9/5 + 32 for x in cvalues]    # with a typical list, you need to loop over it and compute element-wise instead
    >>> print(fvalues)
    [77.54, 76.64, 80.42, 75.02]       # same result, less efficient/readable
\end{verbatim}
\end{block}

\begin{block}{More NumPy}
\protect\hypertarget{more-numpy}{}
A brief look at arrays: NumPy data structures

\begin{verbatim}
    >>> nested_list = [[3.4, 8.7, 9.9], [1.1, -7.8, -0.7], [4.1, 12.3, 4.8]]      # a python nested list
    >>> nested_list
    [[3.4, 8.7, 9.9], [1.1, -7.8, -0.7], [4.1, 12.3, 4.8]]
    >>> A = np.array ([ [3.4, 8.7, 9.9], [1.1, -7.8, -0.7], [4.1, 12.3, 4.8]])    # a numpy array (matrix)
    >>> A
    array([[  3.4   8.7   9.9]
     [  1.1  -7.8  -0.7]
     [  4.1  12.3   4.8]])
\end{verbatim}

Note the formatting of the print. This is indicative of the logic and
illustrates why numpy is the preferred implementation of Python matrix
operations. The SciPy documentation linked previously also includes
NumPy documentation.
\end{block}

\begin{block}{Matplotlib}
\protect\hypertarget{matplotlib}{}
Matplotlib is a basic plotting software. You can generate plots in real
time (X11) or create them and write to files to view later. There is
also a degree of customization afforded in plots. The below example
covers the easiest example:

\begin{verbatim}
    >>> import matplotlib.pyplot as plt
    >>> plt.plot([1,2,3,4])
    [(some memory address)]
    >>> plt.ylabel('some numbers')
    (another memory address)
    >>> plt.show()
\end{verbatim}

You can save the image using something like
\texttt{plt.savefig(\textquotesingle{}image.png\textquotesingle{})}.

See the \href{http://matplotlib.org/contents.html}{matplotlib
documentation} for more information.
\end{block}
\end{block}

\begin{block}{Object Oriented Python}
\protect\hypertarget{object-oriented-python}{}
PSA: Python can also implement classes.

Using classes over functions in Python is generally to the user's
discretion, but standard common sense and logic applies as usual. If
your program expands to the point where you think an object is more
effective than functions, then feel free to implement it.

No instruction on classes will be given here, as it is beyond the scope
of the course. For more information, you can consult an
\href{https://www.jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/}{in-depth
article like this} or look straight at the
\href{https://docs.python.org/2/tutorial/classes.html}{Python
documentation}.
\end{block}
\end{frame}

\begin{frame}[fragile]{A brief Introduction to Scripting}
\protect\hypertarget{a-brief-introduction-to-scripting}{}
\begin{block}{Up until now, we've mostly been playing inside the
interpreter. Here, we'll briefly go over what is required to write a
proper Python program.}
\protect\hypertarget{up-until-now-weve-mostly-been-playing-inside-the-interpreter.-here-well-briefly-go-over-what-is-required-to-write-a-proper-python-program.}{}
\end{block}

\begin{block}{To start:}
\protect\hypertarget{to-start}{}
Strictly speaking, all you need for a Python program is a text file with
the shebang line on top. Recall:

\begin{verbatim}
    #!/usr/bin/env python3
\end{verbatim}

This line indicates to the computer that this is a python program, and
it should look in this location to execute. Similar shebangs may look
like:

\begin{verbatim}
    #!/usr/bin/python
    #!/bin/bash
    #!/usr/bin/perl
    etc.
\end{verbatim}

The shebang is telling the computer to look in the specified directory
for the proper method of execution.
\end{block}

\begin{block}{Why use \texttt{env}?}
\protect\hypertarget{why-use-env}{}
\texttt{env} is used for portability. On *nix machines, there is a path
\texttt{/usr/bin} where most system programs/binaries are installed. If
you need to install multiple versions, this can be an issue. Which
version of Python do you want to use?

This is what \texttt{env} is for. It tells the computer to look at the
current environment, and choose the Python that is currently in use.
This is especially helpful on Orchestra, where we have multiple versions
installed at the same time.
\end{block}

\begin{block}{A basic program}
\protect\hypertarget{a-basic-program}{}
Once you've included the shebang, you can get right to it. Start typing
lines just as you would in the interpreter, and once you execute your
program, each line will resolve itself in order.

\begin{verbatim}
    #!/usr/bin/env python3
    
    print("hello world")
\end{verbatim}

Type this into a text file, and save it as whatever, and include
\texttt{.py} at the end for your own convenience.

To execute this program, just type at the terminal:

\begin{verbatim}
    $ python file.py
\end{verbatim}

You've just written your first python program!
\end{block}

\begin{block}{Basic Structure}
\protect\hypertarget{basic-structure}{}
The previous program is not likely going to be your typical use case.
More complex programs may use modules, functions, classes, etc.

A typical program will have the following structure:

\begin{verbatim}
    #!/usr/bin/env python
    
    # IMPORT EVERYTHING HERE
    
    # CREATE FUNCTIONS AND/OR CLASSES HERE
    
    def main():
        # CODE THAT DOES NOT BELONG IN FUNCTIONS GOES HERE
    
    if __name__ == '__main__':
        main()
\end{verbatim}

To extend the previous trivial example:

\begin{verbatim}
#!/usr/bin/env python3

# no modules were required, so none were imported

# no functions were needed, so none were created

def main():
    print("hello world")

if __name__ == '__main__':
    main()
\end{verbatim}
\end{block}

\begin{block}{What are Functions?}
\protect\hypertarget{what-are-functions}{}
Functions are typically used when you have repetitive code. Instead of
pasting the code over and over, just put it in a function, and use
(``call'') it when needed. For example:

\begin{verbatim}
    def do_thing():
        print("hello world")
        return
\end{verbatim}

Then to reference it, just type elsewhere in your program:

\begin{verbatim}
```
do_thing()
```
\end{verbatim}

and the program will execute the code within the \texttt{do\_thing}
function.

You can also make functions take arguments:

\begin{verbatim}
    def do_thing(phrase):
        print(phrase)
        return
    
    phrase = "hello world"
    do_thing(phrase)
\end{verbatim}

You can also assign values to variables with functions. To do this, make
use of the \texttt{return} keyword. Note that previously, it has been
naked, which means nothing is returned. Python is smart enough to know
what you mean if you omit \texttt{return}, but it's always nice to
include it for consistency.

To extend the previous example:

\begin{verbatim}
    def do_thing(phrase):
        print(phrase)
    
        new_phrase = "goodbye world"
    
        return new_phrase
    
    ...
    
    phrase = "hello world"
    
    phrase2 = do_thing(phrase)
    print(phrase2)
\end{verbatim}

Putting it all together:

\begin{verbatim}
  #!/usr/bin/env python3
  
  def do_thing(phrase):
      """Transform the input phrase into a new phrase."""
      print(phrase)
      new_phrase = "goodbye world"
  
      return new_phrase
  
  def main():
      phrase = "hello world"
      phrase2 = do_thing(phrase)
  
      print(phrase2)
  
  if __name__ == '__main__':
      main()
\end{verbatim}
\end{block}

\begin{block}{Final Thoughts: Compatibility}
\protect\hypertarget{final-thoughts-compatibility}{}
Today's course was taught on 3.6.0.

There are many versions of Python available, and not all are created
equal. Most distinct is the difference between 2.x and 3.x; there are
several syntax changes that will be required to use version 3.x.

For more information, look at this trusty
\href{http://python-future.org/compatible_idioms.html}{2.x to 3.x
compatibility cheat sheet}.

That's it! Thanks for coming!

If you have any questions, feel free to email me directly at
alex\_truong@hms.harvard.edu or visit
\href{https://rc.hms.harvard.edu/\#support}{our website} to submit a
ticket. We also do consulting!
\end{block}
\end{frame}
